; Constant memory locations
    
    ; input locations
        .keyboard_pos $7C00
        .mouse_pos $7D00
    

    ;   VRAM memory locations
        .bgcolor_pos $8000
        .palette_pos $8003

        .screen_flags $80FF

        ; Tilemap information
            ; map table
            .tile_map_p1 $8400
            .tile_map_p2 $8500
            .tile_map_p3 $8600
            .tile_map_p4 $8700

            ; attribute table
            .tile_att_p1 $8800
            .tile_att_p2 $8900
            .tile_att_p3 $8A00
            .tile_att_p4 $8B00

            .tile_line_shift_table $8100
            .tile_line_lock_table $8200
        
        ; Sprite information
        .sprite_x $8C00
        .sprite_y $8D00
        .sprite_tile $8E00
        .sprite_att $8F00

; Game memory locations
    .player_x $150
    .player_y $151
    .player_sprites $152 ; contains the four tiles of the player sprite
    .player_atts $156    ; contains the attributes for said tiles

; Jump to code start point. This call skips all of the subroutines defined after
JMP program_begin

; Clear Titles
; Subroutine: sets all values in the tile map to the value of the accumulator, and the attributes to the value of Y
.clear_tiles
    ;LDA #$FF    ; value to clear the tile with
    ;LDY #0      ; value to clear the attribute with

    ; clear the first page
    LDX #0
    .clear_tiles_pg1
        STA tile_map_p1 x
        STY tile_att_p1 x
        DEX
    BNE clear_tiles_pg1

    ; clear the second page
    LDX #0
    .clear_tiles_pg2
        STA tile_map_p2 x
        STY tile_att_p2 x
        DEX
    BNE clear_tiles_pg2

    ; clear the third page
    LDX #0
    .clear_tiles_pg3
        STA tile_map_p3 x
        STY tile_att_p3 x
        DEX
    BNE clear_tiles_pg3

    ; clear the fourth page
    LDX #0
    .clear_tiles_pg4
        STA tile_map_p4 x
        STY tile_att_p4 x
        DEX
    BNE clear_tiles_pg4

    RTS

; Load graphics
; Subroutine: loads the graphics and palette files
.load_graphics
    ; load the graphics

    LDX #low graphics_file
    LDY #high graphics_file

    STX 1
    STY 2

    LDA #3
    STA 0 ;trigger system call to load the graphics

    CLC
    LDA #10 ; check for success
    ADC $1  ; addr 1 is $FF on failure, will trigger carry flag

    BCS end_program

    ; load the palettes

    LDX #low palette_file
    LDY #high palette_file

    STX 1
    STY 2

    LDA #2
    STA 0 ;trigger system call to load the palettes

    CLC
    LDA #10 ; check for success
    ADC $1  ; addr 1 is $FF on failure, will trigger carry flag

    BCS end_program
    RTS

; Check for quit
; Subroutine: jumps to end_program if the 'escape' key is pressed.
.check_for_quit
    LDA #50 ; get key input
    STA 0

    LDX #52 ; escape key is 52
    LDA keyboard_pos x
    CMP #0

    BNE end_program
    RTS

; Delay X | (Y<<8) milliseconds
; Subroutine: Calls a 'delay' system call using the current values of x and y (x is low, y is high)
.delay_millis
    LDA #14
    STX 1
    STY 2
    STA 0
    RTS

.syscall_print_mem_page
    LDA #253
    STX 1
    STY 2
    STA 0
    RTS

; Initialize Ground
; Subroutine: Uses the data section (.floor_tiles, .floor_attributes) to draw the ground
.init_ground
    .counter $200 ; counter variable at address 200hex
    LDX #32
    STX counter

    LDA floor_tiles         ; value to clear the tile with
    LDY floor_attributes    ; value to clear the attribute with

    ; clear the first line of ground
    LDX #160
    .init_ground_pt1
        STA tile_map_p4 x
        STY tile_att_p4 x
        INX
        DEC counter
    BNE init_ground_pt1  

    ; initialize second and third rows of tiles
    LDX #1 
    LDA floor_tiles X         ; value to clear the tile with
    LDY floor_attributes X    ; value to clear the attribute with

    LDX #64
    STX counter

    LDX #192
    .init_ground_pt2
        STA tile_map_p4 X
        STY tile_att_p4 X
        INX
        DEC counter
    BNE init_ground_pt2

    RTS

; Initialize player sprite
; Subroutine: loads the correct sprite tiles/attributes for the player's tank.
.init_player_sprite
    ; Sprite 0: top left
    ; Sprite 1: top right
    ; Sprite 2: bottom left
    ; Sprite 3: bottom right
    
    LDX #0
    LDA #$30    ; upper tank
    LDY #$10    ; transparency, palette 0

    STA player_sprites x
    STY player_atts x
    INX
    LDY #$90    ; x mirror, transparency
    STA player_sprites x
    STY player_atts x
    INX

    LDA #$31    ; lower tank
    LDY #$10        
    STA player_sprites X
    STY player_atts X
    INX
    LDY #$90    ; x mirror, transparency
    STA player_sprites X
    STY player_atts X

    RTS

; Update player sprite
; Subroutine: Updates the first four sprites in the sprite tables, which are the four parts of the player tank.
.update_player_sprite
    ; Sprite 0: top left, x: -8 y: -8
    ; Sprite 1: top right, x: 0 y: -8
    ; Sprite 2: bottom left, x: -8 y: 0
    ; Sprite 3: bottom right, x: 0 y: 0

    LDX #0 ; first sprite

    SEC     ; riiiight, for subtraction, you have to set the carry flag before starting an operation.
            ; I am not 100% sure why this is but that's how the 6502 worked so I'm trusting the designers of that knew what they were doing.
    LDA player_x
    SBC #8
    STA sprite_x X
    LDA player_y
    SEC
    SBC #8
    STA sprite_y X
    LDA player_sprites X
    STA sprite_tile X
    LDA player_atts X
    STA sprite_att X

    SEC
    INX
    LDA player_x
    STA sprite_x x
    LDA player_y
    SBC #8
    STA sprite_y x
    LDA player_sprites X
    STA sprite_tile X
    LDA player_atts X
    STA sprite_att X

    SEC
    INX
    LDA player_x
    SBC #8
    STA sprite_x X
    LDA player_y
    STA sprite_y X
    LDA player_sprites X
    STA sprite_tile X
    LDA player_atts X
    STA sprite_att X

    INX
    LDA player_x
    STA sprite_x x
    LDA player_y
    STA sprite_y x
    LDA player_sprites X
    STA sprite_tile X
    LDA player_atts X
    STA sprite_att X

    RTS ; 'comment out' the rest of the subroutine.

    LDX #LO sprite_x
    LDY #HI sprite_x
    JSR syscall_print_mem_page

    LDX #LO sprite_y
    LDY #HI sprite_y
    JSR syscall_print_mem_page

    LDX #LO sprite_tile
    LDY #HI sprite_tile
    JSR syscall_print_mem_page

    LDX #LO sprite_att
    LDY #HI sprite_att
    JSR syscall_print_mem_page

    RTS

; Read key input and move the player
.move_player
    LDY player_x

    LDX #38 ; left arrow
    LDA keyboard_pos X
    CMP #00
    BEQ move_player_after_left_check
        TYA
        SEC
        SBC #1
        STA player_x
        .move_player_after_left_check

    LDX #39 ; right arrow
    LDA keyboard_pos X
    CMP #00
    BEQ move_player_after_right_check
        TYA
        CLC
        ADC #1 
        STA player_x
        .move_player_after_right_check

    RTS

.program_begin ; PROGRAM STARTS HERE

JSR load_graphics

LDA #$36
LDY #$06
JSR clear_tiles

; Set background color
    LDX #0
    LDA #49
    STA bgcolor_pos X
    INX
    LDA #47
    STA bgcolor_pos X
    INX
    LDA #53
    STA bgcolor_pos X

JSR init_ground
JSR init_player_sprite

LDA #128
STA player_x

LDA #-32
STA player_y

JSR update_player_sprite

; Main loop
.program_main_loop

    JSR check_for_quit  ; check for quit also gets the keyboard input

    ; keycode 38: left
    ; keycode 39: right

    JSR move_player
    JSR update_player_sprite

    LDA #100
    STA 0   ; graphics refresh system call

    LDX #16 ; delay for 1/60 second
    LDY #0
    JSR delay_millis

    JMP program_main_loop


.end_program
INC 0 ; quit


; Data section

    .graphics_file
    dat "newgame"
    dat 0   ; null terminator, as it's not added automatically by the assembler (possible future todo)

    .palette_file
    dat "exp"
    dat 0

    ; Information about the floor tiles.
    .floor_tiles
    dat $F1 ; top row, use edge tile
    dat $F0 ; bottom row, use normal ground tile

    .floor_attributes
    dat $A3 ; flip vertical and mirror, use palette 3
    dat $03 ; no mirroring, use palette 3